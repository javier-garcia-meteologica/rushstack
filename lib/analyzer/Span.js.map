{"version":3,"file":"Span.js","sourceRoot":"","sources":["../../src/analyzer/Span.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport { StringBuilder } from '@microsoft/tsdoc';\nimport { Sort } from '@rushstack/node-core-library';\n\n/**\n * Specifies various transformations that will be performed by Span.getModifiedText().\n */\nexport class SpanModification {\n  /**\n   * If true, all of the child spans will be omitted from the Span.getModifiedText() output.\n   * @remarks\n   * Also, the modify() operation will not recurse into these spans.\n   */\n  public omitChildren: boolean = false;\n\n  /**\n   * If true, then the Span.separator will be removed from the Span.getModifiedText() output.\n   */\n  public omitSeparatorAfter: boolean = false;\n\n  /**\n   * If true, then Span.getModifiedText() will sort the immediate children according to their Span.sortKey\n   * property.  The separators will also be fixed up to ensure correct indentation.  If the Span.sortKey is undefined\n   * for some items, those items will not be moved, i.e. their array indexes will be unchanged.\n   */\n  public sortChildren: boolean = false;\n\n  /**\n   * Used if the parent span has Span.sortChildren=true.\n   */\n  public sortKey: string | undefined;\n\n  private readonly _span: Span;\n  private _prefix: string | undefined;\n  private _suffix: string | undefined;\n\n  public constructor(span: Span) {\n    this._span = span;\n    this.reset();\n  }\n\n  /**\n   * Allows the Span.prefix text to be changed.\n   */\n  public get prefix(): string {\n    return this._prefix !== undefined ? this._prefix : this._span.prefix;\n  }\n\n  public set prefix(value: string) {\n    this._prefix = value;\n  }\n\n  /**\n   * Allows the Span.suffix text to be changed.\n   */\n  public get suffix(): string {\n    return this._suffix !== undefined ? this._suffix : this._span.suffix;\n  }\n\n  public set suffix(value: string) {\n    this._suffix = value;\n  }\n\n  /**\n   * Reverts any modifications made to this object.\n   */\n  public reset(): void {\n    this.omitChildren = false;\n    this.omitSeparatorAfter = false;\n    this.sortChildren = false;\n    this.sortKey = undefined;\n    this._prefix = undefined;\n    this._suffix = undefined;\n  }\n\n  /**\n   * Effectively deletes the Span from the tree, by skipping its children, skipping its separator,\n   * and setting its prefix/suffix to the empty string.\n   */\n  public skipAll(): void {\n    this.prefix = '';\n    this.suffix = '';\n    this.omitChildren = true;\n    this.omitSeparatorAfter = true;\n  }\n}\n\n/**\n * The Span class provides a simple way to rewrite TypeScript source files\n * based on simple syntax transformations, i.e. without having to process deeper aspects\n * of the underlying grammar.  An example transformation might be deleting JSDoc comments\n * from a source file.\n *\n * @remarks\n * TypeScript's abstract syntax tree (AST) is represented using Node objects.\n * The Node text ignores its surrounding whitespace, and does not have an ordering guarantee.\n * For example, a JSDocComment node can be a child of a FunctionDeclaration node, even though\n * the actual comment precedes the function in the input stream.\n *\n * The Span class is a wrapper for a single Node, that provides access to every character\n * in the input stream, such that Span.getText() will exactly reproduce the corresponding\n * full Node.getText() output.\n *\n * A Span is comprised of these parts, which appear in sequential order:\n * - A prefix\n * - A collection of child spans\n * - A suffix\n * - A separator (e.g. whitespace between this span and the next item in the tree)\n *\n * These parts can be modified via Span.modification.  The modification is applied by\n * calling Span.getModifiedText().\n */\nexport class Span {\n  public readonly node: ts.Node;\n\n  // To improve performance, substrings are not allocated until actually needed\n  public readonly startIndex: number;\n  public readonly endIndex: number;\n\n  public readonly children: Span[];\n\n  public readonly modification: SpanModification;\n\n  private _parent: Span | undefined;\n  private _previousSibling: Span | undefined;\n  private _nextSibling: Span | undefined;\n\n  private _separatorStartIndex: number;\n  private _separatorEndIndex: number;\n\n  public constructor(node: ts.Node) {\n    this.node = node;\n    this.startIndex = node.kind === ts.SyntaxKind.SourceFile ? node.getFullStart() : node.getStart();\n    this.endIndex = node.end;\n    this._separatorStartIndex = 0;\n    this._separatorEndIndex = 0;\n    this.children = [];\n    this.modification = new SpanModification(this);\n\n    let previousChildSpan: Span | undefined = undefined;\n\n    for (const childNode of this.node.getChildren() || []) {\n      const childSpan: Span = new Span(childNode);\n      childSpan._parent = this;\n      childSpan._previousSibling = previousChildSpan;\n\n      if (previousChildSpan) {\n        previousChildSpan._nextSibling = childSpan;\n      }\n\n      this.children.push(childSpan);\n\n      // Normalize the bounds so that a child is never outside its parent\n      if (childSpan.startIndex < this.startIndex) {\n        this.startIndex = childSpan.startIndex;\n      }\n\n      if (childSpan.endIndex > this.endIndex) {\n        // This has never been observed empirically, but here's how we would handle it\n        this.endIndex = childSpan.endIndex;\n        throw new Error('Unexpected AST case');\n      }\n\n      if (previousChildSpan) {\n        if (previousChildSpan.endIndex < childSpan.startIndex) {\n          // There is some leftover text after previous child -- assign it as the separator for\n          // the preceding span.  If the preceding span has no suffix, then assign it to the\n          // deepest preceding span with no suffix.  This heuristic simplifies the most\n          // common transformations, and otherwise it can be fished out using getLastInnerSeparator().\n          let separatorRecipient: Span = previousChildSpan;\n          while (separatorRecipient.children.length > 0) {\n            const lastChild: Span = separatorRecipient.children[separatorRecipient.children.length - 1];\n            if (lastChild.endIndex !== separatorRecipient.endIndex) {\n              // There is a suffix, so we cannot push the separator any further down, or else\n              // it would get printed before this suffix.\n              break;\n            }\n            separatorRecipient = lastChild;\n          }\n          separatorRecipient._separatorStartIndex = previousChildSpan.endIndex;\n          separatorRecipient._separatorEndIndex = childSpan.startIndex;\n        }\n      }\n\n      previousChildSpan = childSpan;\n    }\n  }\n\n  public get kind(): ts.SyntaxKind {\n    return this.node.kind;\n  }\n\n  /**\n   * The parent Span, if any.\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\n   * may have a parent in the AST.\n   */\n  public get parent(): Span | undefined {\n    return this._parent;\n  }\n\n  /**\n   * If the current object is this.parent.children[i], then previousSibling corresponds\n   * to this.parent.children[i-1] if it exists.\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\n   * may have a previous sibling in the AST.\n   */\n  public get previousSibling(): Span | undefined {\n    return this._previousSibling;\n  }\n\n  /**\n   * If the current object is this.parent.children[i], then previousSibling corresponds\n   * to this.parent.children[i+1] if it exists.\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\n   * may have a previous sibling in the AST.\n   */\n  public get nextSibling(): Span | undefined {\n    return this._nextSibling;\n  }\n\n  /**\n   * The text associated with the underlying Node, up to its first child.\n   */\n  public get prefix(): string {\n    if (this.children.length) {\n      // Everything up to the first child\n      return this._getSubstring(this.startIndex, this.children[0].startIndex);\n    } else {\n      return this._getSubstring(this.startIndex, this.endIndex);\n    }\n  }\n\n  /**\n   * The text associated with the underlying Node, after its last child.\n   * If there are no children, this is always an empty string.\n   */\n  public get suffix(): string {\n    if (this.children.length) {\n      // Everything after the last child\n      return this._getSubstring(this.children[this.children.length - 1].endIndex, this.endIndex);\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Whitespace that appeared after this node, and before the \"next\" node in the tree.\n   * Here we mean \"next\" according to an inorder traversal, not necessarily a sibling.\n   */\n  public get separator(): string {\n    return this._getSubstring(this._separatorStartIndex, this._separatorEndIndex);\n  }\n\n  /**\n   * Returns the separator of this Span, or else recursively calls getLastInnerSeparator()\n   * on the last child.\n   */\n  public getLastInnerSeparator(): string {\n    if (this.separator) {\n      return this.separator;\n    }\n    if (this.children.length > 0) {\n      return this.children[this.children.length - 1].getLastInnerSeparator();\n    }\n    return '';\n  }\n\n  /**\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\n   */\n  public findFirstParent(kindToMatch: ts.SyntaxKind): Span | undefined {\n    let current: Span | undefined = this;\n\n    while (current) {\n      if (current.kind === kindToMatch) {\n        return current;\n      }\n      current = current.parent;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Starting from the first character of this span, walk backwards until we find the start of the line,\n   * and return whitespace after that position.\n   *\n   * @remarks\n   * For example, suppose the character buffer contains this text:\n   * ```\n   *              1111111111222222\n   *  012345 6 7890123456789012345\n   * \"line 1\\r\\n  line 2 Example\"\n   * ```\n   *\n   * And suppose the span starts at index 17, i.e. the the \"E\" in example.  The `getIndent()` method would return\n   * two spaces corresponding to the range from index 8 through and including index 9.\n   */\n  public getIndent(): string {\n    const buffer: string = this.node.getSourceFile().text;\n\n    let lineStartIndex: number = 0;\n    let firstNonSpaceIndex: number = this.startIndex;\n\n    let i: number = this.startIndex - 1;\n    while (i >= 0) {\n      const c: number = buffer.charCodeAt(i);\n      if (c === 13 /* \\r */ || c === 10 /* \\n */) {\n        lineStartIndex = i + 1;\n        break;\n      }\n      if (c !== 32 /* space */ && c !== 9 /* tab */) {\n        // We encountered a non-spacing character, so move the firstNonSpaceIndex backwards\n        firstNonSpaceIndex = i;\n      }\n      --i;\n    }\n\n    return buffer.substring(lineStartIndex, firstNonSpaceIndex);\n  }\n\n  /**\n   * Recursively invokes the callback on this Span and all its children.  The callback\n   * can make changes to Span.modification for each node.\n   */\n  public forEach(callback: (span: Span) => void): void {\n    callback(this);\n    for (const child of this.children) {\n      child.forEach(callback);\n    }\n  }\n\n  /**\n   * Returns the original unmodified text represented by this Span.\n   */\n  public getText(): string {\n    let result: string = '';\n    result += this.prefix;\n\n    for (const child of this.children) {\n      result += child.getText();\n    }\n\n    result += this.suffix;\n    result += this.separator;\n\n    return result;\n  }\n\n  /**\n   * Returns the text represented by this Span, after applying all requested modifications.\n   */\n  public getModifiedText(): string {\n    const output: StringBuilder = new StringBuilder();\n\n    this._writeModifiedText({\n      output,\n      separatorOverride: undefined\n    });\n\n    return output.toString();\n  }\n\n  public writeModifiedText(output: StringBuilder): void {\n    this._writeModifiedText({\n      output,\n      separatorOverride: undefined\n    });\n  }\n\n  /**\n   * Returns a diagnostic dump of the tree, showing the prefix/suffix/separator for\n   * each node.\n   */\n  public getDump(indent: string = ''): string {\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\n\n    if (this.prefix) {\n      result += ' pre=[' + this._getTrimmed(this.prefix) + ']';\n    }\n    if (this.suffix) {\n      result += ' suf=[' + this._getTrimmed(this.suffix) + ']';\n    }\n    if (this.separator) {\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\n    }\n    result += '\\n';\n\n    for (const child of this.children) {\n      result += child.getDump(indent + '  ');\n    }\n\n    return result;\n  }\n\n  private _writeModifiedText(options: IWriteModifiedTextOptions): void {\n    options.output.append(this.modification.prefix);\n\n    const childCount: number = this.children.length;\n\n    if (!this.modification.omitChildren) {\n      if (this.modification.sortChildren && childCount > 1) {\n        // We will only sort the items with a sortKey\n        const sortedSubset: Span[] = this.children.filter((x) => x.modification.sortKey !== undefined);\n        const sortedSubsetCount: number = sortedSubset.length;\n\n        // Is there at least one of them?\n        if (sortedSubsetCount > 1) {\n          // Remember the separator for the first and last ones\n          const firstSeparator: string = sortedSubset[0].getLastInnerSeparator();\n          const lastSeparator: string = sortedSubset[sortedSubsetCount - 1].getLastInnerSeparator();\n\n          Sort.sortBy(sortedSubset, (x) => x.modification.sortKey);\n\n          const childOptions: IWriteModifiedTextOptions = { ...options };\n\n          let sortedSubsetIndex: number = 0;\n          for (let index: number = 0; index < childCount; ++index) {\n            let current: Span;\n\n            // Is this an item that we sorted?\n            if (this.children[index].modification.sortKey === undefined) {\n              // No, take the next item from the original array\n              current = this.children[index];\n              childOptions.separatorOverride = undefined;\n            } else {\n              // Yes, take the next item from the sortedSubset\n              current = sortedSubset[sortedSubsetIndex++];\n\n              if (sortedSubsetIndex < sortedSubsetCount) {\n                childOptions.separatorOverride = firstSeparator;\n              } else {\n                childOptions.separatorOverride = lastSeparator;\n              }\n            }\n\n            current._writeModifiedText(childOptions);\n          }\n\n          return;\n        }\n        // (fall through to the other implementations)\n      }\n\n      if (options.separatorOverride !== undefined) {\n        // Special case where the separatorOverride is passed down to the \"last inner separator\" span\n        for (let i: number = 0; i < childCount; ++i) {\n          const child: Span = this.children[i];\n\n          if (\n            // Only the last child inherits the separatorOverride, because only it can contain\n            // the \"last inner separator\" span\n            i < childCount - 1 ||\n            // If this.separator is specified, then we will write separatorOverride below, so don't pass it along\n            this.separator\n          ) {\n            const childOptions: IWriteModifiedTextOptions = { ...options };\n            childOptions.separatorOverride = undefined;\n            child._writeModifiedText(childOptions);\n          } else {\n            child._writeModifiedText(options);\n          }\n        }\n      } else {\n        // The normal simple case\n        for (const child of this.children) {\n          child._writeModifiedText(options);\n        }\n      }\n    }\n\n    options.output.append(this.modification.suffix);\n\n    if (options.separatorOverride !== undefined) {\n      if (this.separator || childCount === 0) {\n        options.output.append(options.separatorOverride);\n      }\n    } else {\n      if (!this.modification.omitSeparatorAfter) {\n        options.output.append(this.separator);\n      }\n    }\n  }\n\n  private _getTrimmed(text: string): string {\n    const trimmed: string = text.replace(/\\r?\\n/g, '\\\\n');\n\n    if (trimmed.length > 100) {\n      return trimmed.substr(0, 97) + '...';\n    }\n    return trimmed;\n  }\n\n  private _getSubstring(startIndex: number, endIndex: number): string {\n    if (startIndex === endIndex) {\n      return '';\n    }\n    return this.node.getSourceFile().text.substring(startIndex, endIndex);\n  }\n}\n\ninterface IWriteModifiedTextOptions {\n  output: StringBuilder;\n  separatorOverride: string | undefined;\n}\n"]}