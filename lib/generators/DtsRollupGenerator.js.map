{"version":3,"file":"DtsRollupGenerator.js","sourceRoot":"","sources":["../../src/generators/DtsRollupGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */\n\nimport * as ts from 'typescript';\nimport { FileSystem, NewlineKind, InternalError } from '@rushstack/node-core-library';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\n\nimport { Collector } from '../collector/Collector';\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\nimport { Span, SpanModification } from '../analyzer/Span';\nimport { AstImport } from '../analyzer/AstImport';\nimport { CollectorEntity } from '../collector/CollectorEntity';\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport { SymbolMetadata } from '../collector/SymbolMetadata';\nimport { StringWriter } from './StringWriter';\nimport { DtsEmitHelpers } from './DtsEmitHelpers';\nimport { DeclarationMetadata } from '../collector/DeclarationMetadata';\n\n/**\n * Used with DtsRollupGenerator.writeTypingsFile()\n */\nexport enum DtsRollupKind {\n  /**\n   * Generate a *.d.ts file for an internal release, or for the trimming=false mode.\n   * This output file will contain all definitions that are reachable from the entry point.\n   */\n  InternalRelease,\n\n  /**\n   * Generate a *.d.ts file for a preview release.\n   * This output file will contain all definitions that are reachable from the entry point,\n   * except definitions marked as \\@alpha or \\@internal.\n   */\n  BetaRelease,\n\n  /**\n   * Generate a *.d.ts file for a public release.\n   * This output file will contain all definitions that are reachable from the entry point,\n   * except definitions marked as \\@beta, \\@alpha, or \\@internal.\n   */\n  PublicRelease\n}\n\nexport class DtsRollupGenerator {\n  /**\n   * Generates the typings file and writes it to disk.\n   *\n   * @param dtsFilename    - The *.d.ts output filename\n   */\n  public static writeTypingsFile(\n    collector: Collector,\n    dtsFilename: string,\n    dtsKind: DtsRollupKind,\n    newlineKind: NewlineKind\n  ): void {\n    const stringWriter: StringWriter = new StringWriter();\n\n    DtsRollupGenerator._generateTypingsFileContent(collector, stringWriter, dtsKind);\n\n    FileSystem.writeFile(dtsFilename, stringWriter.toString(), {\n      convertLineEndings: newlineKind,\n      ensureFolderExists: true\n    });\n  }\n\n  private static _generateTypingsFileContent(\n    collector: Collector,\n    stringWriter: StringWriter,\n    dtsKind: DtsRollupKind\n  ): void {\n    if (collector.workingPackage.tsdocParserContext) {\n      stringWriter.writeLine(collector.workingPackage.tsdocParserContext.sourceRange.toString());\n      stringWriter.writeLine();\n    }\n\n    // Emit the triple slash directives\n    for (const typeDirectiveReference of collector.dtsTypeReferenceDirectives) {\n      // https://github.com/microsoft/TypeScript/blob/611ebc7aadd7a44a4c0447698bfda9222a78cb66/src/compiler/declarationEmitter.ts#L162\n      stringWriter.writeLine(`/// <reference types=\"${typeDirectiveReference}\" />`);\n    }\n\n    for (const libDirectiveReference of collector.dtsLibReferenceDirectives) {\n      stringWriter.writeLine(`/// <reference lib=\"${libDirectiveReference}\" />`);\n    }\n\n    // Emit the imports\n    for (const entity of collector.entities) {\n      if (entity.astEntity instanceof AstImport) {\n        const astImport: AstImport = entity.astEntity;\n\n        // For example, if the imported API comes from an external package that supports AEDoc,\n        // and it was marked as `@internal`, then don't emit it.\n        const symbolMetadata: SymbolMetadata | undefined = collector.tryFetchMetadataForAstEntity(astImport);\n        const maxEffectiveReleaseTag: ReleaseTag = symbolMetadata\n          ? symbolMetadata.maxEffectiveReleaseTag\n          : ReleaseTag.None;\n\n        if (this._shouldIncludeReleaseTag(maxEffectiveReleaseTag, dtsKind)) {\n          DtsEmitHelpers.emitImport(stringWriter, entity, astImport);\n        }\n      }\n    }\n\n    // Emit the regular declarations\n    for (const entity of collector.entities) {\n      const symbolMetadata: SymbolMetadata | undefined = collector.tryFetchMetadataForAstEntity(\n        entity.astEntity\n      );\n      const maxEffectiveReleaseTag: ReleaseTag = symbolMetadata\n        ? symbolMetadata.maxEffectiveReleaseTag\n        : ReleaseTag.None;\n\n      if (!this._shouldIncludeReleaseTag(maxEffectiveReleaseTag, dtsKind)) {\n        if (!collector.extractorConfig.omitTrimmingComments) {\n          stringWriter.writeLine();\n          stringWriter.writeLine(`/* Excluded from this release type: ${entity.nameForEmit} */`);\n        }\n        continue;\n      }\n\n      if (entity.astEntity instanceof AstSymbol) {\n        // Emit all the declarations for this entry\n        for (const astDeclaration of entity.astEntity.astDeclarations || []) {\n          const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n\n          if (!this._shouldIncludeReleaseTag(apiItemMetadata.effectiveReleaseTag, dtsKind)) {\n            if (!collector.extractorConfig.omitTrimmingComments) {\n              stringWriter.writeLine();\n              stringWriter.writeLine(\n                `/* Excluded declaration from this release type: ${entity.nameForEmit} */`\n              );\n            }\n            continue;\n          } else {\n            const span: Span = new Span(astDeclaration.declaration);\n            DtsRollupGenerator._modifySpan(collector, span, entity, astDeclaration, dtsKind);\n            stringWriter.writeLine();\n            stringWriter.writeLine(span.getModifiedText());\n          }\n        }\n      }\n\n      if (!entity.shouldInlineExport) {\n        for (const exportName of entity.exportNames) {\n          DtsEmitHelpers.emitNamedExport(stringWriter, exportName, entity);\n        }\n      }\n    }\n\n    DtsEmitHelpers.emitStarExports(stringWriter, collector);\n\n    // Emit \"export { }\" which is a special directive that prevents consumers from importing declarations\n    // that don't have an explicit \"export\" modifier.\n    stringWriter.writeLine();\n    stringWriter.writeLine('export { }');\n  }\n\n  /**\n   * Before writing out a declaration, _modifySpan() applies various fixups to make it nice.\n   */\n  private static _modifySpan(\n    collector: Collector,\n    span: Span,\n    entity: CollectorEntity,\n    astDeclaration: AstDeclaration,\n    dtsKind: DtsRollupKind\n  ): void {\n    const previousSpan: Span | undefined = span.previousSibling;\n\n    let recurseChildren: boolean = true;\n    switch (span.kind) {\n      case ts.SyntaxKind.JSDocComment:\n        // If the @packageDocumentation comment seems to be attached to one of the regular API items,\n        // omit it.  It gets explictly emitted at the top of the file.\n        if (span.node.getText().match(/(?:\\s|\\*)@packageDocumentation(?:\\s|\\*)/gi)) {\n          span.modification.skipAll();\n        }\n\n        // For now, we don't transform JSDoc comment nodes at all\n        recurseChildren = false;\n        break;\n\n      case ts.SyntaxKind.ExportKeyword:\n      case ts.SyntaxKind.DefaultKeyword:\n      case ts.SyntaxKind.DeclareKeyword:\n        // Delete any explicit \"export\" or \"declare\" keywords -- we will re-add them below\n        span.modification.skipAll();\n        break;\n\n      case ts.SyntaxKind.InterfaceKeyword:\n      case ts.SyntaxKind.ClassKeyword:\n      case ts.SyntaxKind.EnumKeyword:\n      case ts.SyntaxKind.NamespaceKeyword:\n      case ts.SyntaxKind.ModuleKeyword:\n      case ts.SyntaxKind.TypeKeyword:\n      case ts.SyntaxKind.FunctionKeyword:\n        // Replace the stuff we possibly deleted above\n        let replacedModifiers: string = '';\n\n        // Add a declare statement for root declarations (but not for nested declarations)\n        if (!astDeclaration.parent) {\n          replacedModifiers += 'declare ';\n        }\n\n        if (entity.shouldInlineExport) {\n          replacedModifiers = 'export ' + replacedModifiers;\n        }\n\n        if (previousSpan && previousSpan.kind === ts.SyntaxKind.SyntaxList) {\n          // If there is a previous span of type SyntaxList, then apply it before any other modifiers\n          // (e.g. \"abstract\") that appear there.\n          previousSpan.modification.prefix = replacedModifiers + previousSpan.modification.prefix;\n        } else {\n          // Otherwise just stick it in front of this span\n          span.modification.prefix = replacedModifiers + span.modification.prefix;\n        }\n        break;\n\n      case ts.SyntaxKind.VariableDeclaration:\n        // Is this a top-level variable declaration?\n        // (The logic below does not apply to variable declarations that are part of an explicit \"namespace\" block,\n        // since the compiler prefers not to emit \"declare\" or \"export\" keywords for those declarations.)\n        if (!span.parent) {\n          // The VariableDeclaration node is part of a VariableDeclarationList, however\n          // the Entry.followedSymbol points to the VariableDeclaration part because\n          // multiple definitions might share the same VariableDeclarationList.\n          //\n          // Since we are emitting a separate declaration for each one, we need to look upwards\n          // in the ts.Node tree and write a copy of the enclosing VariableDeclarationList\n          // content (e.g. \"var\" from \"var x=1, y=2\").\n          const list: ts.VariableDeclarationList | undefined = TypeScriptHelpers.matchAncestor(span.node, [\n            ts.SyntaxKind.VariableDeclarationList,\n            ts.SyntaxKind.VariableDeclaration\n          ]);\n          if (!list) {\n            // This should not happen unless the compiler API changes somehow\n            throw new InternalError('Unsupported variable declaration');\n          }\n          const listPrefix: string = list\n            .getSourceFile()\n            .text.substring(list.getStart(), list.declarations[0].getStart());\n          span.modification.prefix = 'declare ' + listPrefix + span.modification.prefix;\n          span.modification.suffix = ';';\n\n          if (entity.shouldInlineExport) {\n            span.modification.prefix = 'export ' + span.modification.prefix;\n          }\n\n          const declarationMetadata: DeclarationMetadata = collector.fetchDeclarationMetadata(astDeclaration);\n          if (declarationMetadata.tsdocParserContext) {\n            // Typically the comment for a variable declaration is attached to the outer variable statement\n            // (which may possibly contain multiple variable declarations), so it's not part of the Span.\n            // Instead we need to manually inject it.\n            let originalComment: string = declarationMetadata.tsdocParserContext.sourceRange.toString();\n            if (!/\\r?\\n\\s*$/.test(originalComment)) {\n              originalComment += '\\n';\n            }\n            span.modification.prefix = originalComment + span.modification.prefix;\n          }\n        }\n        break;\n\n      case ts.SyntaxKind.Identifier:\n        {\n          const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(\n            span.node as ts.Identifier\n          );\n\n          if (referencedEntity) {\n            if (!referencedEntity.nameForEmit) {\n              // This should never happen\n              throw new InternalError('referencedEntry.nameForEmit is undefined');\n            }\n\n            span.modification.prefix = referencedEntity.nameForEmit;\n            // For debugging:\n            // span.modification.prefix += '/*R=FIX*/';\n          } else {\n            // For debugging:\n            // span.modification.prefix += '/*R=KEEP*/';\n          }\n        }\n        break;\n\n      case ts.SyntaxKind.ImportType:\n        {\n          const node: ts.ImportTypeNode = span.node as ts.ImportTypeNode;\n          const referencedEntity: CollectorEntity | undefined = collector.tryGetEntityForNode(node);\n\n          if (referencedEntity) {\n            if (!referencedEntity.nameForEmit) {\n              // This should never happen\n              throw new InternalError('referencedEntry.nameForEmit is undefined');\n            }\n\n            if (referencedEntity.astEntity instanceof AstSymbol) {\n              // Replace with internal symbol\n\n              span.modification.skipAll();\n              span.modification.prefix = referencedEntity.nameForEmit;\n            } else {\n              // External ImportType nodes are associated with a StarImport\n              // Replace node with nameForEmit and recover imported names from node qualifier\n\n              const qualifier: string = node.qualifier ? node.qualifier.getText() : '';\n              const replacement: string = qualifier\n                ? `${referencedEntity.nameForEmit}.${qualifier}`\n                : referencedEntity.nameForEmit;\n\n              span.modification.skipAll();\n              span.modification.prefix = replacement;\n            }\n          }\n        }\n        break;\n    }\n\n    if (recurseChildren) {\n      for (const child of span.children) {\n        let childAstDeclaration: AstDeclaration = astDeclaration;\n\n        // Should we trim this node?\n        let trimmed: boolean = false;\n        if (AstDeclaration.isSupportedSyntaxKind(child.kind)) {\n          childAstDeclaration = collector.astSymbolTable.getChildAstDeclarationByNode(\n            child.node,\n            astDeclaration\n          );\n          const releaseTag: ReleaseTag = collector.fetchApiItemMetadata(childAstDeclaration)\n            .effectiveReleaseTag;\n\n          if (!this._shouldIncludeReleaseTag(releaseTag, dtsKind)) {\n            let nodeToTrim: Span = child;\n\n            // If we are trimming a variable statement, then we need to trim the outer VariableDeclarationList\n            // as well.\n            if (child.kind === ts.SyntaxKind.VariableDeclaration) {\n              const variableStatement: Span | undefined = child.findFirstParent(\n                ts.SyntaxKind.VariableStatement\n              );\n              if (variableStatement !== undefined) {\n                nodeToTrim = variableStatement;\n              }\n            }\n\n            const modification: SpanModification = nodeToTrim.modification;\n\n            // Yes, trim it and stop here\n            const name: string = childAstDeclaration.astSymbol.localName;\n            modification.omitChildren = true;\n\n            if (!collector.extractorConfig.omitTrimmingComments) {\n              modification.prefix = `/* Excluded from this release type: ${name} */`;\n            } else {\n              modification.prefix = '';\n            }\n            modification.suffix = '';\n\n            if (nodeToTrim.children.length > 0) {\n              // If there are grandchildren, then keep the last grandchild's separator,\n              // since it often has useful whitespace\n              modification.suffix = nodeToTrim.children[nodeToTrim.children.length - 1].separator;\n            }\n\n            if (nodeToTrim.nextSibling) {\n              // If the thing we are trimming is followed by a comma, then trim the comma also.\n              // An example would be an enum member.\n              if (nodeToTrim.nextSibling.kind === ts.SyntaxKind.CommaToken) {\n                // Keep its separator since it often has useful whitespace\n                modification.suffix += nodeToTrim.nextSibling.separator;\n                nodeToTrim.nextSibling.modification.skipAll();\n              }\n            }\n\n            trimmed = true;\n          }\n        }\n\n        if (!trimmed) {\n          DtsRollupGenerator._modifySpan(collector, child, entity, childAstDeclaration, dtsKind);\n        }\n      }\n    }\n  }\n\n  private static _shouldIncludeReleaseTag(releaseTag: ReleaseTag, dtsKind: DtsRollupKind): boolean {\n    switch (dtsKind) {\n      case DtsRollupKind.InternalRelease:\n        return true;\n      case DtsRollupKind.BetaRelease:\n        // NOTE: If the release tag is \"None\", then we don't have enough information to trim it\n        return (\n          releaseTag === ReleaseTag.Beta || releaseTag === ReleaseTag.Public || releaseTag === ReleaseTag.None\n        );\n      case DtsRollupKind.PublicRelease:\n        return releaseTag === ReleaseTag.Public || releaseTag === ReleaseTag.None;\n    }\n\n    throw new Error(`${DtsRollupKind[dtsKind]} is not implemented`);\n  }\n}\n"]}