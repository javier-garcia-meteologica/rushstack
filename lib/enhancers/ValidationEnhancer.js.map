{"version":3,"file":"ValidationEnhancer.js","sourceRoot":"","sources":["../../src/enhancers/ValidationEnhancer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport { Collector } from '../collector/Collector';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport { SymbolMetadata } from '../collector/SymbolMetadata';\nimport { CollectorEntity } from '../collector/CollectorEntity';\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\n\nexport class ValidationEnhancer {\n  public static analyze(collector: Collector): void {\n    const alreadyWarnedSymbols: Set<AstSymbol> = new Set<AstSymbol>();\n\n    for (const entity of collector.entities) {\n      if (entity.astEntity instanceof AstSymbol) {\n        if (entity.exported) {\n          entity.astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\n            ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedSymbols);\n          });\n\n          const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(entity.astEntity);\n          ValidationEnhancer._checkForInternalUnderscore(collector, entity, entity.astEntity, symbolMetadata);\n          ValidationEnhancer._checkForInconsistentReleaseTags(collector, entity.astEntity, symbolMetadata);\n        }\n      }\n    }\n  }\n\n  private static _checkForInternalUnderscore(\n    collector: Collector,\n    collectorEntity: CollectorEntity,\n    astSymbol: AstSymbol,\n    symbolMetadata: SymbolMetadata\n  ): void {\n    let needsUnderscore: boolean = false;\n\n    if (symbolMetadata.maxEffectiveReleaseTag === ReleaseTag.Internal) {\n      if (!astSymbol.parentAstSymbol) {\n        // If it's marked as @internal and has no parent, then it needs and underscore.\n        // We use maxEffectiveReleaseTag because a merged declaration would NOT need an underscore in a case like this:\n        //\n        //   /** @public */\n        //   export enum X { }\n        //\n        //   /** @internal */\n        //   export namespace X { }\n        //\n        // (The above normally reports an error \"ae-different-release-tags\", but that may be suppressed.)\n        needsUnderscore = true;\n      } else {\n        // If it's marked as @internal and the parent isn't obviously already @internal, then it needs an underscore.\n        //\n        // For example, we WOULD need an underscore for a merged declaration like this:\n        //\n        //   /** @internal */\n        //   export namespace X {\n        //     export interface _Y { }\n        //   }\n        //\n        //   /** @public */\n        //   export class X {\n        //     /** @internal */\n        //     public static _Y(): void { }   // <==== different from parent\n        //   }\n        const parentSymbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\n        if (parentSymbolMetadata.maxEffectiveReleaseTag > ReleaseTag.Internal) {\n          needsUnderscore = true;\n        }\n      }\n    }\n\n    if (needsUnderscore) {\n      for (const exportName of collectorEntity.exportNames) {\n        if (exportName[0] !== '_') {\n          collector.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.InternalMissingUnderscore,\n            `The name \"${exportName}\" should be prefixed with an underscore` +\n              ` because the declaration is marked as @internal`,\n            astSymbol,\n            { exportName }\n          );\n        }\n      }\n    }\n  }\n\n  private static _checkForInconsistentReleaseTags(\n    collector: Collector,\n    astSymbol: AstSymbol,\n    symbolMetadata: SymbolMetadata\n  ): void {\n    if (astSymbol.isExternal) {\n      // For now, don't report errors for external code.  If the developer cares about it, they should run\n      // API Extractor separately on the external project\n      return;\n    }\n\n    // Normally we will expect all release tags to be the same.  Arbitrarily we choose the maxEffectiveReleaseTag\n    // as the thing they should all match.\n    const expectedEffectiveReleaseTag: ReleaseTag = symbolMetadata.maxEffectiveReleaseTag;\n\n    // This is set to true if we find a declaration whose release tag is different from expectedEffectiveReleaseTag\n    let mixedReleaseTags: boolean = false;\n\n    // This is set to false if we find a declaration that is not a function/method overload\n    let onlyFunctionOverloads: boolean = true;\n\n    // This is set to true if we find a declaration that is @internal\n    let anyInternalReleaseTags: boolean = false;\n\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      switch (astDeclaration.declaration.kind) {\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.MethodDeclaration:\n          break;\n        default:\n          onlyFunctionOverloads = false;\n      }\n\n      if (effectiveReleaseTag !== expectedEffectiveReleaseTag) {\n        mixedReleaseTags = true;\n      }\n\n      if (effectiveReleaseTag === ReleaseTag.Internal) {\n        anyInternalReleaseTags = true;\n      }\n    }\n\n    if (mixedReleaseTags) {\n      if (!onlyFunctionOverloads) {\n        collector.messageRouter.addAnalyzerIssue(\n          ExtractorMessageId.DifferentReleaseTags,\n          'This symbol has another declaration with a different release tag',\n          astSymbol\n        );\n      }\n\n      if (anyInternalReleaseTags) {\n        collector.messageRouter.addAnalyzerIssue(\n          ExtractorMessageId.InternalMixedReleaseTag,\n          `Mixed release tags are not allowed for \"${astSymbol.localName}\" because one of its declarations` +\n            ` is marked as @internal`,\n          astSymbol\n        );\n      }\n    }\n  }\n\n  private static _checkReferences(\n    collector: Collector,\n    astDeclaration: AstDeclaration,\n    alreadyWarnedSymbols: Set<AstSymbol>\n  ): void {\n    const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\n    const declarationReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n    for (const referencedEntity of astDeclaration.referencedAstEntities) {\n      if (referencedEntity instanceof AstSymbol) {\n        // If this is e.g. a member of a namespace, then we need to be checking the top-level scope to see\n        // whether it's exported.\n        //\n        // TODO: Technically we should also check each of the nested scopes along the way.\n        const rootSymbol: AstSymbol = referencedEntity.rootAstSymbol;\n\n        if (!rootSymbol.isExternal) {\n          const collectorEntity: CollectorEntity | undefined = collector.tryGetCollectorEntity(rootSymbol);\n\n          if (collectorEntity && collectorEntity.exported) {\n            const referencedMetadata: SymbolMetadata = collector.fetchSymbolMetadata(referencedEntity);\n            const referencedReleaseTag: ReleaseTag = referencedMetadata.maxEffectiveReleaseTag;\n\n            if (ReleaseTag.compare(declarationReleaseTag, referencedReleaseTag) > 0) {\n              collector.messageRouter.addAnalyzerIssue(\n                ExtractorMessageId.IncompatibleReleaseTags,\n                `The symbol \"${astDeclaration.astSymbol.localName}\"` +\n                  ` is marked as ${ReleaseTag.getTagName(declarationReleaseTag)},` +\n                  ` but its signature references \"${referencedEntity.localName}\"` +\n                  ` which is marked as ${ReleaseTag.getTagName(referencedReleaseTag)}`,\n                astDeclaration\n              );\n            }\n          } else {\n            const entryPointFilename: string = path.basename(\n              collector.workingPackage.entryPointSourceFile.fileName\n            );\n\n            if (!alreadyWarnedSymbols.has(referencedEntity)) {\n              alreadyWarnedSymbols.add(referencedEntity);\n\n              // The main usage scenario for ECMAScript symbols is to attach private data to a JavaScript object,\n              // so as a special case, we do NOT report them as forgotten exports.\n              if (!ValidationEnhancer._isEcmaScriptSymbol(referencedEntity)) {\n                collector.messageRouter.addAnalyzerIssue(\n                  ExtractorMessageId.ForgottenExport,\n                  `The symbol \"${rootSymbol.localName}\" needs to be exported` +\n                    ` by the entry point ${entryPointFilename}`,\n                  astDeclaration\n                );\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Detect an AstSymbol that refers to an ECMAScript symbol declaration such as:\n  //\n  // const mySymbol: unique symbol = Symbol('mySymbol');\n  private static _isEcmaScriptSymbol(astSymbol: AstSymbol): boolean {\n    if (astSymbol.astDeclarations.length !== 1) {\n      return false;\n    }\n\n    // We are matching a form like this:\n    //\n    // - VariableDeclaration:\n    //   - Identifier:  pre=[mySymbol]\n    //   - ColonToken:  pre=[:] sep=[ ]\n    //   - TypeOperator:\n    //     - UniqueKeyword:  pre=[unique] sep=[ ]\n    //     - SymbolKeyword:  pre=[symbol]\n    const astDeclaration: AstDeclaration = astSymbol.astDeclarations[0];\n    if (ts.isVariableDeclaration(astDeclaration.declaration)) {\n      const variableTypeNode: ts.TypeNode | undefined = astDeclaration.declaration.type;\n      if (variableTypeNode) {\n        for (const token of variableTypeNode.getChildren()) {\n          if (token.kind === ts.SyntaxKind.SymbolKeyword) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"]}